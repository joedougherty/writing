===============================
The Generator that Could Not Be
===============================


Your friend George is a real math whiz. He has all these interesting ideas about infinity to share.

Every now and again he tries to explain some of his ideas, but they never quite seem to stick. 

You happen to both know a bit of Python. George decides to explain some of his ideas in terms of programming.

"First off, let's represent the Natural numbers." George proffers the following:

    <code>

    def naturals():
        n = 1
        while True:
            yield n
            n += 1


    N = naturals()

    </code>

Likewise, the odds, evens, etc.

    <code>

    def odds():
        n = 1
        while True:
            yield n
            n += 2

    Odds = odds()

    </code>

This seems all fine and good as far as it goes. You start work on a Primes generator. 

George waits patiently for you to run a few tests. Once you are satisfied he inquires: 

"How many primes are there again?" You recall Euclid's demonstration that we can always

generate a new prime number by multiplying the largest two known primes and adding 1.

"Infinitely many." 

Your terseness belies your anticipation of his next question. 

You know that something fun must be around the corner.

"How about, oh, numbers that end in 0?"

You smile to yourself as you dash off the following into the buffer:

    <code>

    def ends_in_zero():
        n = 0
        while True:
            yield n
            n += 10
            yield -n

    Ends_in_Zero = ends_in_zero()
        
    </code>

You cackle maniacally as you prepare to call `len([_ for _ in Ends_in_Zero])` knowing full well this 

will pin a core and render the current terminal sesssion useless. George defers to your apparent temporary 

insanity and agrees to be direct in his pedagogy moving forward.

"Seriously, though. It's the same thing. They're both infinite."

What about the second `yield` in ends_in_zero()? Doesn't that somehow produce twice as many numbers as, say,

naturals() which only `yield`s once per iteration?

You've known George long enough to know when he is only asking rhetorically. Thankfully, that's

almost always followed by a period of clear, but rapid, explication.

"You are right, of course! There *are* just as many numbers ending in 0 as there are naturals, even when including

the negative ones."

"The key is that we can map every natural number to precisely one number being produced in the new generator."

(You notice George starting to get a distant look in his eye(s?).)

Here is a different way to express `ends_in_zero`:

    <code>

	def ends_in_zero():
		N = naturals() # Let's fire up a new naturals generator
		
		def map_nat_to_eiz(n):
			if n == 0:
				return 0
			elif n % 2 == 0:
				return (n // 2 * -1) * 10
			else:
				return ((n + 1) // 2) * 10

		return (map_nat_to_eiz(_) for _ in N)

	Ends_in_Zero = ends_in_zero()

    </code>

This version helps to make the one-to-one correspondence more obvious (explicit?).

Every time `next(Ends_in_Zero)` is called, `N` is advanced to produce a new value. 

We could use this as an informal definition of one-to-one correspondence:

	As long as the series you want to express can be generated by 
	calling a mapping function (that returns precisely one value) 
	for every value yielded by N, then that series must be of the 
	same "size" of N.

Mathematicians call this the _cardinality_ of a set.

George shows some clever mappings.

	<code>

	# Map naturals to rationals to show 
	# they have one-to-one correspondence
	def inverse_paring(n):
		pass

	</code>



[ -- Not sure if this belongs here -- ]
George asks enthusiastically about the second `yield` in your ends_in_zero implementation. 

"Well, I realized we needed to include the negative numbers that ended in zero as well." 
[ -- Not sure if this belongs here -- ]

